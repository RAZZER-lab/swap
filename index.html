<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YRS Staking DApp</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Ethers.js library for blockchain interaction (official CDN) -->
    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js"></script>
    <style>
        .card { margin-bottom: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .status-connected { color: #198754; font-weight: bold; }
        .status-disconnected { color: #dc3545; font-weight: bold; }
        .function-section { border-left: 4px solid #0d6efd; padding-left: 1rem; margin-bottom: 2rem; }
        .wallet-info { background-color: #f8f9fa; padding: 1rem; border-radius: 0.375rem; }
        .gas-error, .rpc-error { color: #dc3545; font-size: 0.9em; }
        .retry-btn { margin-top: 0.5rem; }
        .browser-warning { display: none; background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; }
    </style>
</head>
<body>
    <div class="container mt-4 mb-5">
        <!-- Browser Compatibility Warning -->
        <div id="browserWarning" class="browser-warning">
            <strong>‚ö†Ô∏è Browser Compatibility Notice</strong>
            <p class="mb-1">Firefox may have compatibility issues with MetaMask. If you encounter connection problems:</p>
            <ul class="small mb-2">
                <li>Ensure MetaMask is installed and unlocked</li>
                <li>Try refreshing the page</li>
                <li>Check if MetaMask is connected to the correct network (Sepolia)</li>
                <li>As a last resort, try using Chrome or Brave browser</li>
            </ul>
        </div>

        <h1 class="text-center mb-4">YRS Staking Interface</h1>
        
        <!-- Connection Status and Wallet Info -->
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Wallet Connection</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <p>Connection Status: <span id="connectionStatus" class="status-disconnected">Not Connected</span></p>
                        <div id="rpcWarning" class="alert alert-warning" style="display: none;">
                            <strong>‚ö†Ô∏è RPC Circuit Breaker Open</strong>
                            <p class="mb-1">The RPC endpoint is temporarily limiting requests. This is usually temporary and can be resolved by:</p>
                            <ul class="small mb-2">
                                <li>Waiting a few moments and retrying</li>
                                <li>Refreshing the page</li>
                                <li>Switching to a different RPC endpoint in MetaMask</li>
                                <li>Resetting your MetaMask account (Settings ‚Üí Advanced ‚Üí Reset Account)</li>
                            </ul>
                            <button id="retryInitBtn" class="btn btn-sm btn-outline-primary retry-btn">Retry Connection</button>
                        </div>
                        <div id="limitedModeWarning" class="alert alert-info" style="display: none;">
                            <strong>‚ÑπÔ∏è Limited Functionality</strong>
                            <p class="mb-1">Connected in read-only mode. Write operations are disabled due to browser compatibility. Balances can still be viewed. For full functionality, try Chrome or Brave.</p>
                            <button id="retryInitBtnLimited" class="btn btn-sm btn-outline-primary retry-btn">Retry Full Connection</button>
                        </div>
                        <div id="networkAlert" class="alert network-alert" style="display: none;">
                            <strong>üåê Network Change Required</strong>
                            <p class="mb-1">You need to switch to the Sepolia testnet to use this DApp.</p>
                            <button id="switchNetworkBtn" class="btn btn-sm btn-warning mt-1">Switch to Sepolia</button>
                        </div>
                        <button id="connectButton" class="btn btn-primary">Connect MetaMask</button>
                        <button id="disconnectButton" class="btn btn-secondary" style="display: none;">Disconnect</button>
                    </div>
                    <div class="col-md-6">
                        <div id="walletInfo" style="display: none;">
                            <p>Connected Address: <strong id="connectedAddress"></strong></p>
                            <p>Network: <strong id="networkInfo"></strong></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Token Balances -->
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Token Balances</h5>
                <button id="refreshBalances" class="btn btn-sm btn-outline-secondary" disabled>Refresh</button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <p>wZYS Balance: <strong id="wZYSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>YRS Balance: <strong id="YRSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>Contract YRS Reserve: <strong id="contractYRSBalance">0</strong></p>
                    </div>
                </div>
                <p id="balanceError" class="rpc-error" style="display: none;">Failed to load balances due to RPC error. Retry after fixing connection.</p>
            </div>
        </div>

        <!-- Contract Interaction Sections -->
        
        <!-- Buy YRS Tokens -->
        <div class="function-section">
            <h3>Buy YRS Tokens (10% Bonus)</h3>
            <p class="text-muted">Exchange your wZYS for YRS tokens and receive a 10% bonus.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="buyWZYSAmount" class="form-label">wZYS Amount to Spend</label>
                        <input type="number" class="form-control" id="buyWZYSAmount" placeholder="Enter wZYS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minYRSOut" class="form-label">Minimum YRS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minYRSOut" placeholder="Enter minimum YRS expected" step="0.000000000000000001">
                    </div>
                    <button id="buyButton" class="btn btn-success" disabled>Buy YRS</button>
                    <div id="buyOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Sell YRS Tokens -->
        <div class="function-section">
            <h3>Sell YRS Tokens (10% Penalty)</h3>
            <p class="text-muted">Exchange your YRS tokens back to wZYS with a 10% reduction.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="sellYRSAmount" class="form-label">YRS Amount to Sell</label>
                        <input type="number" class="form-control" id="sellYRSAmount" placeholder="Enter YRS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minWZYSOut" class="form-label">Minimum wZYS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minWZYSOut" placeholder="Enter minimum wZYS expected" step="0.000000000000000001">
                    </div>
                    <button id="sellButton" class="btn btn-warning" disabled>Sell YRS</button>
                    <div id="sellOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Burn YRS Tokens -->
        <div class="function-section">
            <h3>Burn YRS Tokens</h3>
            <p class="text-muted">Permanently remove YRS tokens from circulation.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="burnAmount" class="form-label">YRS Amount to Burn</label>
                        <input type="number" class="form-control" id="burnAmount" placeholder="Enter YRS amount to burn" step="0.000000000000000001">
                    </div>
                    <button id="burnButton" class="btn btn-danger" disabled>Burn YRS</button>
                    <div id="burnOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Admin Functions (Only for Contract Owner) -->
        <div class="function-section">
            <h3>Admin Functions</h3>
            <p class="text-muted">These functions are only available to the contract owner.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="recoverTokenAddress" class="form-label">Token Address to Recover</label>
                        <input type="text" class="form-control" id="recoverTokenAddress" placeholder="Enter token address">
                    </div>
                    <div class="mb-3">
                        <label for="recoverAmount" class="form-label">Amount to Recover</label>
                        <input type="number" class="form-control" id="recoverAmount" placeholder="Enter amount to recover" step="0.000000000000000001">
                    </div>
                    <button id="recoverButton" class="btn btn-info" disabled>Recover ERC20 Tokens</button>
                    <div id="recoverOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // =============================================
        // Configuration and Contract Setup
        // =============================================
        
        // Contract address and ABI
        const contractAddress = '0x0eba64eA7d1055Cb87654EC554360741C31650E6';
        const EXPECTED_CHAIN_ID = 11155111; // Sepolia testnet
        const SEPOLIA_HEX_CHAIN_ID = '0xaa36a7'; // Sepolia chain ID in hexadecimal
        
        // Proper ABI for the YRSStaking contract (inferred from function signatures)
        const contractABI = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "wZYSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minYRSOut", "type": "uint256"}
                ],
                "name": "buy1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "YRSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minWZYSOut", "type": "uint256"}
                ],
                "name": "sell1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "burn",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "tokenAddress", "type": "address"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "recoverERC20",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalYieldReserveShares",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalWZYSDeposited",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "wZYS",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "YRS",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "BONUS_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "PENALTY_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Standard ERC20 ABI for token interactions
        const erc20ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_subtractedValue", "type": "uint256"}
                ],
                "name": "decreaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_addedValue", "type": "uint256"}
                ],
                "name": "increaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    {"name": "_owner", "type": "address"},
                    {"name": "_spender", "type": "address"}
                ],
                "name": "allowance",
                "outputs": [{"name": "", "type": "uint256"}],
                "type": "function"
            }
        ];

        // Global variables
        let provider;
        let signer;
        let contract;
        let userAddress;
        let wZYSToken;
        let YRSToken;
        let initFailed = false;
        let circuitBreakerRetryCount = 0;
        const MAX_CIRCUIT_BREAKER_RETRIES = 3;
        const isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;

        // =============================================
        // Enhanced Provider Detection for Firefox
        // =============================================
        
        function getEthereumProvider() {
            // Check for modern EIP-1193 provider
            if (window.ethereum) {
                return window.ethereum;
            }
            // Check for legacy web3 provider
            else if (window.web3 && window.web3.currentProvider) {
                return window.web3.currentProvider;
            }
            // No provider found
            return null;
        }

        function handleRPCCircuitBreaker(error, context = '') {
            const circuitBreakerIndicators = [
                'circuit breaker',
                'execution prevented',
                'rpc error',
                'transport is closing',
                'unavailable'
                // Removed 'unknown account' as it's a connection issue, not RPC
            ];
            
            const isCircuitBreakerError = circuitBreakerIndicators.some(indicator => 
                error.message?.toLowerCase().includes(indicator) || 
                error.toString().toLowerCase().includes(indicator)
            );
            
            if (isCircuitBreakerError || error.code === -32603 || error.code === 'SERVER_ERROR' || error.code === 'UNSUPPORTED_OPERATION') {
                console.error(`RPC/Circuit Breaker Error in ${context}:`, error);
                document.getElementById('rpcWarning').style.display = 'block';
                initFailed = true;
                circuitBreakerRetryCount++;
                
                // Disable write buttons if init failed
                toggleWriteButtons(false);
                return true;
            }
            return false;
        }

        async function retryableCall(callFn, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const result = await callFn();
                    // Reset circuit breaker retry count on successful call
                    if (i > 0) {
                        circuitBreakerRetryCount = 0;
                        initFailed = false;
                        document.getElementById('rpcWarning').style.display = 'none';
                    }
                    return result;
                } catch (error) {
                    if (handleRPCCircuitBreaker(error, `Retry ${i + 1} for call`)) {
                        if (circuitBreakerRetryCount >= MAX_CIRCUIT_BREAKER_RETRIES) {
                            console.warn('Max circuit breaker retries reached, giving up');
                            break;
                        }
                    }
                    if (i < maxRetries - 1 && !initFailed) {
                        console.log(`Retry ${i + 1} failed, waiting ${delay * (i + 1)}ms before retry`);
                        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                    } else {
                        throw error;
                    }
                }
            }
            throw new Error('All retry attempts failed');
        }

        function toggleWriteButtons(enabled) {
            const buttons = ['buyButton', 'sellButton', 'burnButton', 'recoverButton'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = !enabled;
            });
        }

        // =============================================
        // Network Switching Functions
        // =============================================
        
        async function switchToSepoliaNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: SEPOLIA_HEX_CHAIN_ID }],
                });
                return true;
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: SEPOLIA_HEX_CHAIN_ID,
                                    chainName: 'Sepolia Test Network',
                                    rpcUrls: ['https://rpc.sepolia.org/', 'https://sepolia.infura.io/v3/'],
                                    blockExplorerUrls: ['https://sepolia.etherscan.io/'],
                                    nativeCurrency: {
                                        name: 'Sepolia Ether',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                },
                            ],
                        });
                        return true;
                    } catch (addError) {
                        console.error('Error adding Sepolia network:', addError);
                        alert('Failed to add Sepolia network to MetaMask. Please add it manually.');
                        return false;
                    }
                } else if (switchError.code === 4001) {
                    console.log('User rejected network switch');
                    return false;
                } else {
                    console.error('Error switching to Sepolia:', switchError);
                    return false;
                }
            }
        }

        // =============================================
        // DOM Content Loaded Event Listener
        // =============================================
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Enhanced provider detection
            const ethereumProvider = getEthereumProvider();
            
            if (!ethereumProvider) {
                alert('Please install MetaMask to use this dApp!');
                if (isFirefox) {
                    document.getElementById('browserWarning').style.display = 'block';
                }
                return;
            }

            // Check if we're in Firefox and show warning
            if (isFirefox) {
                document.getElementById('browserWarning').style.display = 'block';
            }

            try {
                // Initialize the provider with the detected Ethereum provider
                provider = new ethers.providers.Web3Provider(ethereumProvider);
                
                // Initialize contract object (read-only until signer is connected)
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            } catch (error) {
                console.error('Error initializing contract:', error);
                alert('Error initializing contract. Please check the console for details.');
                return;
            }

            // Set up event listeners
            document.getElementById('connectButton').addEventListener('click', connectWallet);
            document.getElementById('disconnectButton').addEventListener('click', disconnectWallet);
            document.getElementById('buyButton').addEventListener('click', buyYRS);
            document.getElementById('sellButton').addEventListener('click', sellYRS);
            document.getElementById('burnButton').addEventListener('click', burnYRS);
            document.getElementById('recoverButton').addEventListener('click', recoverTokens);
            document.getElementById('refreshBalances').addEventListener('click', refreshAllBalances);
            document.getElementById('retryInitBtn').addEventListener('click', retryInitialization);
            document.getElementById('retryInitBtnLimited').addEventListener('click', retryInitialization);
            document.getElementById('switchNetworkBtn').addEventListener('click', switchToSepoliaNetwork);

            // Enhanced event listeners for account and chain changes
            if (ethereumProvider.on) {
                ethereumProvider.on('accountsChanged', async function(accounts) {
                    if (accounts.length === 0) {
                        disconnectWallet();
                    } else {
                        await connectWallet(accounts[0]);
                    }
                });

                ethereumProvider.on('chainChanged', async function(chainId) {
                    // Reset circuit breaker state on chain change
                    circuitBreakerRetryCount = 0;
                    initFailed = false;
                    document.getElementById('rpcWarning').style.display = 'none';
                    document.getElementById('limitedModeWarning').style.display = 'none';
                    
                    await checkNetwork();
                    if (userAddress) {
                        await refreshAllBalances();
                    }
                });
            }

            // Initial check for existing connection using eth_accounts (non-prompting)
            try {
                const accounts = await ethereumProvider.request({ method: 'eth_accounts' });
                if (accounts.length > 0) {
                    await connectWallet(accounts[0]);
                }
            } catch (error) {
                console.log('No accounts found or permission error:', error);
                // Continue without auto-connection
            }
        });

        // =============================================
        // Enhanced Wallet Connection Functions
        // =============================================
        
        async function connectWallet(overrideAddress = null) {
            try {
                const ethereumProvider = getEthereumProvider();
                if (!ethereumProvider) {
                    throw new Error('No Ethereum provider found. Please install MetaMask.');
                }

                let accounts;
                if (overrideAddress) {
                    accounts = [overrideAddress];
                } else {
                    // Use the detected provider for account request
                    accounts = await ethereumProvider.request({ method: 'eth_requestAccounts' });
                }
                
                if (accounts.length === 0) {
                    throw new Error('No accounts available');
                }

                // Re-initialize provider with current context
                provider = new ethers.providers.Web3Provider(ethereumProvider);
                
                // Small delay to ensure provider state update (helps in Firefox)
                await new Promise(resolve => setTimeout(resolve, 300));
                
                // Get the signer with proper error handling
                let tempSigner;
                try {
                    tempSigner = provider.getSigner();
                    userAddress = await tempSigner.getAddress(); // Verify address to ensure readiness
                } catch (signerError) {
                    console.error('Error getting signer:', signerError);
                    if (signerError.message.includes('unknown account')) {
                        throw new Error('Failed to access account. Ensure MetaMask is unlocked and connected.');
                    }
                    throw signerError;
                }
                
                signer = tempSigner;
                
                // Update contract instance with signer for write operations
                contract = contract.connect(signer);
                
                // Check network first
                const isCorrectNetwork = await checkNetwork();
                if (!isCorrectNetwork) {
                    document.getElementById('networkAlert').style.display = 'block';
                } else {
                    document.getElementById('networkAlert').style.display = 'none';
                }
                
                // Initialize token contracts (now works with provider for read-only)
                try {
                    await retryableCall(initializeTokenContracts);
                    initFailed = false;
                    document.getElementById('rpcWarning').style.display = 'none';
                    document.getElementById('limitedModeWarning').style.display = 'none';
                } catch (error) {
                    console.error('Failed to initialize after retries:', error);
                    if (handleRPCCircuitBreaker(error, 'initializeTokenContracts')) {
                        // Keep connected but initFailed for writes
                    }
                }
                
                // Refresh balances
                await refreshAllBalances();
                
                // Update UI for full connection
                updateConnectionStatus(true, true); // connected, full access
                
                // Enable refresh and writes if appropriate
                document.getElementById('refreshBalances').disabled = false;
                toggleWriteButtons(!initFailed && isCorrectNetwork);
                
            } catch (error) {
                console.error('Error connecting to wallet:', error);
                if (error.code !== 4001 && !handleRPCCircuitBreaker(error, 'connectWallet')) {
                    if (error.message.includes('unknown account') || error.code === 'UNSUPPORTED_OPERATION') {
                        // Fallback to read-only mode
                        userAddress = accounts ? accounts[0] : null;
                        signer = null;
                        initFailed = true; // For writes
                        document.getElementById('limitedModeWarning').style.display = 'block';
                        updateConnectionStatus(true, false); // connected, read-only
                        document.getElementById('refreshBalances').disabled = false;
                        toggleWriteButtons(false);
                        // Try to initialize for read-only
                        try {
                            await initializeTokenContracts();
                            await refreshAllBalances();
                        } catch (initError) {
                            console.error('Failed to init read-only:', initError);
                            document.getElementById('balanceError').style.display = 'block';
                        }
                        return;
                    }
                    alert('Error connecting to MetaMask: ' + error.message);
                }
            }
        }

        function updateConnectionStatus(connected, fullAccess) {
            if (connected) {
                const statusEl = document.getElementById('connectionStatus');
                statusEl.textContent = fullAccess ? 'Connected' : 'Connected (Read-Only)';
                statusEl.className = 'status-connected';
                document.getElementById('connectButton').style.display = 'none';
                document.getElementById('disconnectButton').style.display = 'inline-block';
                updateWalletInfo();
            } else {
                // Reset to disconnected (handled in disconnectWallet)
            }
        }

        async function retryInitialization() {
            if (!userAddress) return;
            try {
                document.getElementById('rpcWarning').style.display = 'none';
                document.getElementById('limitedModeWarning').style.display = 'none';
                
                // Re-initialize provider and signer
                const ethereumProvider = getEthereumProvider();
                if (ethereumProvider) {
                    provider = new ethers.providers.Web3Provider(ethereumProvider);
                    await new Promise(resolve => setTimeout(resolve, 300));
                    signer = provider.getSigner();
                    userAddress = await signer.getAddress();
                    contract = new ethers.Contract(contractAddress, contractABI, provider).connect(signer);
                }
                
                await retryableCall(initializeTokenContracts, 2, 2000);
                initFailed = false;
                await refreshAllBalances();
                document.getElementById('balanceError').style.display = 'none';
                document.getElementById('limitedModeWarning').style.display = 'none';
                
                const isCorrectNetwork = await checkNetwork();
                document.getElementById('refreshBalances').disabled = false;
                toggleWriteButtons(isCorrectNetwork);
                updateConnectionStatus(true, true);
            } catch (error) {
                console.error('Retry failed:', error);
                if (error.message.includes('unknown account') || error.code === 'UNSUPPORTED_OPERATION') {
                    document.getElementById('limitedModeWarning').style.display = 'block';
                    updateConnectionStatus(true, false);
                } else {
                    handleRPCCircuitBreaker(error, 'retryInitialization');
                }
            }
        }

        async function checkNetwork() {
            try {
                const network = await provider.getNetwork();
                const isCorrectNetwork = network.chainId === EXPECTED_CHAIN_ID;
                
                if (!isCorrectNetwork) {
                    console.log(`Expected Chain ID ${EXPECTED_CHAIN_ID}, but connected to ${network.chainId}. Showing network switch prompt.`);
                    document.getElementById('networkAlert').style.display = 'block';
                    toggleWriteButtons(false);
                    return false;
                } else {
                    document.getElementById('networkAlert').style.display = 'none';
                    if (!initFailed) {
                        toggleWriteButtons(!!signer);
                    }
                    return true;
                }
            } catch (error) {
                console.error('Error checking network:', error);
                if (handleRPCCircuitBreaker(error, 'checkNetwork')) {
                    return false;
                }
                document.getElementById('networkAlert').style.display = 'block';
                return false;
            }
        }

        function disconnectWallet() {
            userAddress = null;
            signer = null;
            const ethereumProvider = getEthereumProvider();
            if (ethereumProvider) {
                provider = new ethers.providers.Web3Provider(ethereumProvider);
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            }
            wZYSToken = null;
            YRSToken = null;
            initFailed = false;
            circuitBreakerRetryCount = 0;
            
            document.getElementById('connectionStatus').textContent = 'Not Connected';
            document.getElementById('connectionStatus').className = 'status-disconnected';
            document.getElementById('walletInfo').style.display = 'none';
            document.getElementById('connectedAddress').textContent = '';
            document.getElementById('networkInfo').textContent = '';
            document.getElementById('connectButton').style.display = 'inline-block';
            document.getElementById('disconnectButton').style.display = 'none';
            document.getElementById('rpcWarning').style.display = 'none';
            document.getElementById('limitedModeWarning').style.display = 'none';
            document.getElementById('networkAlert').style.display = 'none';
            document.getElementById('balanceError').style.display = 'none';
            
            // Reset balances
            document.getElementById('wZYSBalance').textContent = '0';
            document.getElementById('YRSBalance').textContent = '0';
            document.getElementById('contractYRSBalance').textContent = '0';
            
            // Clear outputs
            document.querySelectorAll('[id$="Output"]').forEach(el => el.innerHTML = '');
            
            document.getElementById('refreshBalances').disabled = true;
            toggleWriteButtons(false);
        }

        async function updateWalletInfo() {
            if (userAddress) {
                try {
                    const network = await provider.getNetwork();
                    document.getElementById('connectedAddress').textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(38)}`;
                    document.getElementById('networkInfo').textContent = `${network.name} (Chain ID: ${network.chainId})`;
                    document.getElementById('walletInfo').style.display = 'block';
                } catch (error) {
                    console.error('Error updating wallet info:', error);
                    if (handleRPCCircuitBreaker(error, 'updateWalletInfo')) {
                        return;
                    }
                }
            }
        }

        // =============================================
        // Token and Balance Functions
        // =============================================
        
        async function initializeTokenContracts() {
            let wZYSAddress, YRSAddress;
            try {
                wZYSAddress = await retryableCall(() => contract.wZYS());
                YRSAddress = await retryableCall(() => contract.YRS());
            } catch (error) {
                console.error('Failed to fetch token addresses:', error);
                throw error;
            }
            
            // Create contract instances for the tokens (use signer if available, else provider for read-only)
            const tokenConnector = signer || provider;
            wZYSToken = new ethers.Contract(wZYSAddress, erc20ABI, tokenConnector);
            YRSToken = new ethers.Contract(YRSAddress, erc20ABI, tokenConnector);
        }

        async function getTokenAllowance(tokenContract, spender) {
            try {
                return await retryableCall(() => tokenContract.allowance(userAddress, spender));
            } catch (error) {
                console.error('Error getting allowance:', error);
                return ethers.BigNumber.from(0);
            }
        }

        async function ensureApproval(tokenContract, spender, amount, outputId) {
            if (!signer) {
                throw new Error('No signer available for approval transaction');
            }
            
            const allowance = await getTokenAllowance(tokenContract, spender);
            const amountWei = ethers.utils.parseUnits(amount.toString(), 18);
            
            if (allowance.lt(amountWei)) {
                try {
                    document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Approving tokens... Waiting for confirmation.</div>';
                    
                    let approveTx;
                    try {
                        approveTx = await tokenContract.increaseAllowance(spender, amountWei, { gasLimit: 100000 });
                    } catch {
                        approveTx = await tokenContract.approve(spender, amountWei, { gasLimit: 100000 });
                    }
                    
                    await approveTx.wait();
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success mt-2">Approval successful!</div>';
                } catch (error) {
                    console.error('Approval failed:', error);
                    if (handleRPCCircuitBreaker(error, 'ensureApproval')) {
                        throw new Error('RPC Error during approval');
                    }
                    document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Approval failed: ${error.message}</div>`;
                    throw error;
                }
            } else {
                document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Sufficient allowance found. Skipping approval.</div>';
            }
        }

        async function refreshAllBalances() {
            if (!userAddress || !wZYSToken || !YRSToken) {
                return;
            }
            
            try {
                const wZYSBalance = await retryableCall(() => wZYSToken.balanceOf(userAddress));
                document.getElementById('wZYSBalance').textContent = parseFloat(ethers.utils.formatUnits(wZYSBalance, 18)).toFixed(4);
                
                const YRSBalance = await retryableCall(() => YRSToken.balanceOf(userAddress));
                document.getElementById('YRSBalance').textContent = parseFloat(ethers.utils.formatUnits(YRSBalance, 18)).toFixed(4);
                
                const contractBalance = await retryableCall(() => YRSToken.balanceOf(contractAddress));
                document.getElementById('contractYRSBalance').textContent = parseFloat(ethers.utils.formatUnits(contractBalance, 18)).toFixed(4);
                
                document.getElementById('balanceError').style.display = 'none';
            } catch (error) {
                console.error('Error refreshing balances:', error);
                if (handleRPCCircuitBreaker(error, 'refreshAllBalances')) {
                    document.getElementById('balanceError').style.display = 'block';
                }
            }
        }

        // =============================================
        // Contract Interaction Functions
        // =============================================
        
        async function buyYRS() {
            if (!userAddress || !signer || initFailed) {
                alert('Please connect your wallet with write access and resolve any issues!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const wZYSAmount = parseFloat(document.getElementById('buyWZYSAmount').value);
            const minYRSOut = parseFloat(document.getElementById('minYRSOut').value);
            
            if (!wZYSAmount || !minYRSOut || wZYSAmount <= 0 || minYRSOut <= 0) {
                alert('Please enter valid positive amounts!');
                return;
            }
            
            const outputId = 'buyOutput';
            try {
                const wZYSAddress = await retryableCall(() => contract.wZYS());
                const wZYSTokenWithSigner = new ethers.Contract(wZYSAddress, erc20ABI, signer);
                await ensureApproval(wZYSTokenWithSigner, contractAddress, wZYSAmount, outputId);
                
                const buyTx = await contract.buy1(
                    ethers.utils.parseUnits(wZYSAmount.toString(), 18),
                    ethers.utils.parseUnits(minYRSOut.toString(), 18),
                    { gasLimit: 500000 }
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Buy transaction submitted! Waiting for confirmation...</div>';
                const receipt = await buyTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully bought YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error buying YRS:', error);
                let errorMsg = error.message;
                if (handleRPCCircuitBreaker(error, 'buyYRS')) {
                    errorMsg = 'RPC Circuit Breaker: Execution blocked. Resolve in MetaMask and retry.';
                } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. This may be due to insufficient funds, wrong parameters, or contract revert. Try adjusting slippage or amounts.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balances, allowances, or slippage protection.';
                } else if (error.code === 'UNSUPPORTED_OPERATION') {
                    errorMsg = 'Operation not supported. This may be a browser compatibility issue. Try using Chrome or Brave.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function sellYRS() {
            if (!userAddress || !signer || initFailed) {
                alert('Please connect your wallet with write access and resolve any issues!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const YRSAmount = parseFloat(document.getElementById('sellYRSAmount').value);
            const minWZYSOut = parseFloat(document.getElementById('minWZYSOut').value);
            
            if (!YRSAmount || !minWZYSOut || YRSAmount <= 0 || minWZYSOut <= 0) {
                alert('Please enter valid positive amounts!');
                return;
            }
            
            const outputId = 'sellOutput';
            try {
                const YRSAddress = await retryableCall(() => contract.YRS());
                const YRSTokenWithSigner = new ethers.Contract(YRSAddress, erc20ABI, signer);
                await ensureApproval(YRSTokenWithSigner, contractAddress, YRSAmount, outputId);
                
                const sellTx = await contract.sell1(
                    ethers.utils.parseUnits(YRSAmount.toString(), 18),
                    ethers.utils.parseUnits(minWZYSOut.toString(), 18),
                    { gasLimit: 500000 }
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Sell transaction submitted! Waiting for confirmation...</div>';
                const receipt = await sellTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully sold YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error selling YRS:', error);
                let errorMsg = error.message;
                if (handleRPCCircuitBreaker(error, 'sellYRS')) {
                    errorMsg = 'RPC Circuit Breaker: Execution blocked. Resolve in MetaMask and retry.';
                } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. This may be due to insufficient funds, wrong parameters, or contract revert. Try adjusting slippage or amounts.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balances, allowances, or slippage protection.';
                } else if (error.code === 'UNSUPPORTED_OPERATION') {
                    errorMsg = 'Operation not supported. This may be a browser compatibility issue. Try using Chrome or Brave.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function burnYRS() {
            if (!userAddress || !signer || initFailed) {
                alert('Please connect your wallet with write access and resolve any issues!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const burnAmount = parseFloat(document.getElementById('burnAmount').value);
            
            if (!burnAmount || burnAmount <= 0) {
                alert('Please enter a valid positive amount to burn!');
                return;
            }
            
            const outputId = 'burnOutput';
            try {
                const YRSAddress = await retryableCall(() => contract.YRS());
                const YRSTokenWithSigner = new ethers.Contract(YRSAddress, erc20ABI, signer);
                await ensureApproval(YRSTokenWithSigner, contractAddress, burnAmount, outputId);
                
                const burnTx = await contract.burn(
                    ethers.utils.parseUnits(burnAmount.toString(), 18),
                    { gasLimit: 300000 }
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Burn transaction submitted! Waiting for confirmation...</div>';
                const receipt = await burnTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully burned YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error burning YRS:', error);
                let errorMsg = error.message;
                if (handleRPCCircuitBreaker(error, 'burnYRS')) {
                    errorMsg = 'RPC Circuit Breaker: Execution blocked. Resolve in MetaMask and retry.';
                } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. Try a smaller amount.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balance or allowance.';
                } else if (error.code === 'UNSUPPORTED_OPERATION') {
                    errorMsg = 'Operation not supported. This may be a browser compatibility issue. Try using Chrome or Brave.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function recoverTokens() {
            if (!userAddress || !signer || initFailed) {
                alert('Please connect your wallet with write access and resolve any issues!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const tokenAddress = document.getElementById('recoverTokenAddress').value;
            const amount = parseFloat(document.getElementById('recoverAmount').value);
            
            if (!tokenAddress || !amount || amount <= 0) {
                alert('Please fill in all fields with valid positive amounts!');
                return;
            }
            
            if (!ethers.utils.isAddress(tokenAddress)) {
                alert('Please enter a valid token address!');
                return;
            }
            
            const outputId = 'recoverOutput';
            try {
                const recoverTx = await contract.recoverERC20(
                    tokenAddress,
                    ethers.utils.parseUnits(amount.toString(), 18),
                    { gasLimit: 200000 }
                );
                
                document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Recovery transaction submitted! Waiting for confirmation...</div>';
                const receipt = await recoverTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully recovered tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
            } catch (error) {
                console.error('Error recovering tokens:', error);
                let errorMsg = error.message;
                if (handleRPCCircuitBreaker(error, 'recoverTokens')) {
                    errorMsg = 'RPC Circuit Breaker: Execution blocked. Resolve in MetaMask and retry.';
                } else if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. Ensure you are the contract owner.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Only contract owner can recover tokens.';
                } else if (error.code === 'UNSUPPORTED_OPERATION') {
                    errorMsg = 'Operation not supported. This may be a browser compatibility issue. Try using Chrome or Brave.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }
    </script>
</body>
</html>
