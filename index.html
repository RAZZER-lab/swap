<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YRS Staking DApp</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Ethers.js library for blockchain interaction -->
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        .card { margin-bottom: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .status-connected { color: #198754; font-weight: bold; }
        .status-disconnected { color: #dc3545; font-weight: bold; }
        .function-section { border-left: 4px solid #0d6efd; padding-left: 1rem; margin-bottom: 2rem; }
        .wallet-info { background-color: #f8f9fa; padding: 1rem; border-radius: 0.375rem; }
        .error-message { color: #dc3545; font-size: 0.9em; }
        .retry-btn { margin-top: 0.5rem; }
    </style>
</head>
<body>
    <div class="container mt-4 mb-5">
        <h1 class="text-center mb-4">YRS Staking Interface</h1>
        
        <!-- Connection Status and Wallet Info -->
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Wallet Connection</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <p>Connection Status: <span id="connectionStatus" class="status-disconnected">Not Connected</span></p>
                        <div id="connectionError" class="alert alert-danger" style="display: none;">
                            <strong>‚ö†Ô∏è Connection Error</strong>
                            <p class="mb-1">Failed to connect to MetaMask. Please ensure:</p>
                            <ul class="small mb-2">
                                <li>MetaMask is installed and unlocked</li>
                                <li>You're connected to the Sepolia testnet</li>
                                <li>Try refreshing the page</li>
                            </ul>
                            <button id="retryConnectionBtn" class="btn btn-sm btn-outline-primary retry-btn">Retry Connection</button>
                        </div>
                        <div id="networkAlert" class="alert network-alert" style="display: none;">
                            <strong>üåê Network Change Required</strong>
                            <p class="mb-1">You need to switch to the Sepolia testnet to use this DApp.</p>
                            <button id="switchNetworkBtn" class="btn btn-sm btn-warning mt-1">Switch to Sepolia</button>
                        </div>
                        <button id="connectButton" class="btn btn-primary">Connect MetaMask</button>
                        <button id="disconnectButton" class="btn btn-secondary" style="display: none;">Disconnect</button>
                    </div>
                    <div class="col-md-6">
                        <div id="walletInfo" style="display: none;">
                            <p>Connected Address: <strong id="connectedAddress"></strong></p>
                            <p>Network: <strong id="networkInfo"></strong></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Token Balances -->
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Token Balances</h5>
                <button id="refreshBalances" class="btn btn-sm btn-outline-secondary" disabled>Refresh</button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <p>wZYS Balance: <strong id="wZYSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>YRS Balance: <strong id="YRSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>Contract YRS Reserve: <strong id="contractYRSBalance">0</strong></p>
                    </div>
                </div>
                <p id="balanceError" class="error-message" style="display: none;">Failed to load balances. Please check your connection.</p>
            </div>
        </div>

        <!-- Contract Interaction Sections -->
        
        <!-- Buy YRS Tokens -->
        <div class="function-section">
            <h3>Buy YRS Tokens (10% Bonus)</h3>
            <p class="text-muted">Exchange your wZYS for YRS tokens and receive a 10% bonus.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="buyWZYSAmount" class="form-label">wZYS Amount to Spend</label>
                        <input type="number" class="form-control" id="buyWZYSAmount" placeholder="Enter wZYS amount" step="0.000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minYRSOut" class="form-label">Minimum YRS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minYRSOut" placeholder="Enter minimum YRS expected" step="0.000000000000000001">
                    </div>
                    <button id="buyButton" class="btn btn-success" disabled>Buy YRS</button>
                    <div id="buyOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Sell YRS Tokens -->
        <div class="function-section">
            <h3>Sell YRS Tokens (10% Penalty)</h3>
            <p class="text-muted">Exchange your YRS tokens back to wZYS with a 10% reduction.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="sellYRSAmount" class="form-label">YRS Amount to Sell</label>
                        <input type="number" class="form-control" id="sellYRSAmount" placeholder="Enter YRS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minWZYSOut" class="form-label">Minimum wZYS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minWZYSOut" placeholder="Enter minimum wZYS expected" step="0.000000000001">
                    </div>
                    <button id="sellButton" class="btn btn-warning" disabled>Sell YRS</button>
                    <div id="sellOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Burn YRS Tokens -->
        <div class="function-section">
            <h3>Burn YRS Tokens</h3>
            <p class="text-muted">Permanently remove YRS tokens from circulation.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="burnAmount" class="form-label">YRS Amount to Burn</label>
                        <input type="number" class="form-control" id="burnAmount" placeholder="Enter YRS amount to burn" step="0.000000000000000001">
                    </div>
                    <button id="burnButton" class="btn btn-danger" disabled>Burn YRS</button>
                    <div id="burnOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Admin Functions (Only for Contract Owner) -->
        <div class="function-section">
            <h3>Admin Functions</h3>
            <p class="text-muted">These functions are only available to the contract owner.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="recoverTokenAddress" class="form-label">Token Address to Recover</label>
                        <input type="text" class="form-control" id="recoverTokenAddress" placeholder="Enter token address">
                    </div>
                    <div class="mb-3">
                        <label for="recoverAmount" class="form-label">Amount to Recover</label>
                        <input type="number" class="form-control" id="recoverAmount" placeholder="Enter amount to recover" step="0.000000000000000001">
                    </div>
                    <button id="recoverButton" class="btn btn-info" disabled>Recover ERC20 Tokens</button>
                    <div id="recoverOutput" class="mt-2"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // =============================================
        // Configuration and Contract Setup
        // =============================================
        
        // Contract address and ABI
        const contractAddress = '0x0eba64eA7d1055Cb87654EC554360741C31650E6';
        const EXPECTED_CHAIN_ID = 11155111; // Sepolia testnet
        const SEPOLIA_HEX_CHAIN_ID = '0xaa36a7'; // Sepolia chain ID in hexadecimal
        
        // Proper ABI for the YRSStaking contract
        const contractABI = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "wZYSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minYRSOut", "type": "uint256"}
                ],
                "name": "buy1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "YRSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minWZYSOut", "type": "uint256"}
                ],
                "name": "sell1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "burn",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "tokenAddress", "type": "address"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "recoverERC20",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalYieldReserveShares",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalWZYSDeposited",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "wZYS",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "YRS",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "BONUS_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "PENALTY_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Standard ERC20 ABI for token interactions
        const erc20ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_subtractedValue", "type": "uint256"}
                ],
                "name": "decreaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_addedValue", "type": "uint256"}
                ],
                "name": "increaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [
                    {"name": "_owner", "type": "address"},
                    {"name": "_spender", "type": "address"}
                ],
                "name": "allowance",
                "outputs": [{"name": "", "type": "uint256"}],
                "type": "function"
            }
        ];

        // Global variables
        let provider;
        let signer;
        let contract;
        let userAddress;
        let wZYSToken;
        let YRSToken;
        let wZYSDecimals = 12; // wZYS has 12 decimals
        let YRSDecimals = 18; // YRS has 18 decimals

        // =============================================
        // Network Switching Functions
        // =============================================
        
        async function switchToSepoliaNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: SEPOLIA_HEX_CHAIN_ID }],
                });
                return true;
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: SEPOLIA_HEX_CHAIN_ID,
                                    chainName: 'Sepolia Test Network',
                                    rpcUrls: ['https://rpc.sepolia.org/', 'https://sepolia.infura.io/v3/'],
                                    blockExplorerUrls: ['https://sepolia.etherscan.io/'],
                                    nativeCurrency: {
                                        name: 'Sepolia Ether',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                },
                            ],
                        });
                        return true;
                    } catch (addError) {
                        console.error('Error adding Sepolia network:', addError);
                        alert('Failed to add Sepolia network to MetaMask. Please add it manually.');
                        return false;
                    }
                } else if (switchError.code === 4001) {
                    console.log('User rejected network switch');
                    return false;
                } else {
                    console.error('Error switching to Sepolia:', switchError);
                    return false;
                }
            }
        }

        // =============================================
        // DOM Content Loaded Event Listener
        // =============================================
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Check if MetaMask is installed
            if (!window.ethereum) {
                alert('Please install MetaMask to use this dApp!');
                return;
            }

            try {
                // Initialize the provider
                provider = new ethers.providers.Web3Provider(window.ethereum, "any");
                
                // Initialize contract object (read-only until signer is connected)
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            } catch (error) {
                console.error('Error initializing contract:', error);
                alert('Error initializing contract. Please check the console for details.');
                return;
            }

            // Set up event listeners
            document.getElementById('connectButton').addEventListener('click', connectWallet);
            document.getElementById('disconnectButton').addEventListener('click', disconnectWallet);
            document.getElementById('buyButton').addEventListener('click', buyYRS);
            document.getElementById('sellButton').addEventListener('click', sellYRS);
            document.getElementById('burnButton').addEventListener('click', burnYRS);
            document.getElementById('recoverButton').addEventListener('click', recoverTokens);
            document.getElementById('refreshBalances').addEventListener('click', refreshAllBalances);
            document.getElementById('retryConnectionBtn').addEventListener('click', retryConnection);
            document.getElementById('switchNetworkBtn').addEventListener('click', switchToSepoliaNetwork);

            // Event listeners for account and chain changes
            window.ethereum.on('accountsChanged', async function(accounts) {
                if (accounts.length === 0) {
                    disconnectWallet();
                } else {
                    await connectWallet(accounts[0]);
                }
            });

            window.ethereum.on('chainChanged', async function(chainId) {
                await checkNetwork();
                if (userAddress) {
                    await refreshAllBalances();
                }
            });

            // Initial check for existing connection
            try {
                const accounts = await provider.listAccounts();
                if (accounts.length > 0) {
                    await connectWallet(accounts[0]);
                }
            } catch (error) {
                console.log('No accounts found or error listing accounts:', error);
            }
        });

        // =============================================
        // Wallet Connection Functions
        // =============================================
        
        async function connectWallet(overrideAddress = null) {
            try {
                if (!window.ethereum) {
                    throw new Error('No Ethereum provider found. Please install MetaMask.');
                }

                let accounts;
                if (overrideAddress) {
                    accounts = [overrideAddress];
                } else {
                    accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                }
                
                if (accounts.length === 0) {
                    throw new Error('No accounts available');
                }

                // Re-initialize provider with current context
                provider = new ethers.providers.Web3Provider(window.ethereum, "any");
                
                // Get the signer
                signer = provider.getSigner();
                userAddress = accounts[0];
                
                // Update contract instance with signer for write operations
                contract = contract.connect(signer);
                
                // Check network first
                const isCorrectNetwork = await checkNetwork();
                if (!isCorrectNetwork) {
                    document.getElementById('networkAlert').style.display = 'block';
                } else {
                    document.getElementById('networkAlert').style.display = 'none';
                }
                
                // Update UI
                updateWalletInfo();
                
                // Initialize token contracts
                try {
                    await initializeTokenContracts();
                    document.getElementById('connectionError').style.display = 'none';
                } catch (error) {
                    console.error('Failed to initialize token contracts:', error);
                    document.getElementById('connectionError').style.display = 'block';
                }
                
                // Refresh balances
                await refreshAllBalances();
                
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'status-connected';
                document.getElementById('connectButton').style.display = 'none';
                document.getElementById('disconnectButton').style.display = 'inline-block';
                
                // Enable interactions if we're on the correct network
                toggleInteractionButtons(isCorrectNetwork);
                
            } catch (error) {
                console.error('Error connecting to wallet:', error);
                if (error.code !== 4001) {
                    document.getElementById('connectionError').style.display = 'block';
                }
            }
        }

        async function retryConnection() {
            if (!userAddress) return;
            try {
                document.getElementById('connectionError').style.display = 'none';
                
                // Re-initialize provider and signer
                provider = new ethers.providers.Web3Provider(window.ethereum, "any");
                signer = provider.getSigner();
                contract = new ethers.Contract(contractAddress, contractABI, provider).connect(signer);
                
                await initializeTokenContracts();
                await refreshAllBalances();
                document.getElementById('balanceError').style.display = 'none';
                
                const isCorrectNetwork = await checkNetwork();
                toggleInteractionButtons(isCorrectNetwork);
            } catch (error) {
                console.error('Retry failed:', error);
                document.getElementById('connectionError').style.display = 'block';
            }
        }

        async function checkNetwork() {
            try {
                const network = await provider.getNetwork();
                const isCorrectNetwork = network.chainId === EXPECTED_CHAIN_ID;
                
                if (!isCorrectNetwork) {
                    console.log(`Expected Chain ID ${EXPECTED_CHAIN_ID}, but connected to ${network.chainId}. Showing network switch prompt.`);
                    document.getElementById('networkAlert').style.display = 'block';
                    toggleInteractionButtons(false);
                    return false;
                } else {
                    document.getElementById('networkAlert').style.display = 'none';
                    toggleInteractionButtons(true);
                    return true;
                }
            } catch (error) {
                console.error('Error checking network:', error);
                document.getElementById('networkAlert').style.display = 'block';
                return false;
            }
        }

        function disconnectWallet() {
            userAddress = null;
            signer = null;
            if (window.ethereum) {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            }
            wZYSToken = null;
            YRSToken = null;
            
            document.getElementById('connectionStatus').textContent = 'Not Connected';
            document.getElementById('connectionStatus').className = 'status-disconnected';
            document.getElementById('walletInfo').style.display = 'none';
            document.getElementById('connectedAddress').textContent = '';
            document.getElementById('networkInfo').textContent = '';
            document.getElementById('connectButton').style.display = 'inline-block';
            document.getElementById('disconnectButton').style.display = 'none';
            document.getElementById('connectionError').style.display = 'none';
            document.getElementById('networkAlert').style.display = 'none';
            document.getElementById('balanceError').style.display = 'none';
            
            // Reset balances
            document.getElementById('wZYSBalance').textContent = '0';
            document.getElementById('YRSBalance').textContent = '0';
            document.getElementById('contractYRSBalance').textContent = '0';
            
            // Clear outputs
            document.querySelectorAll('[id$="Output"]').forEach(el => el.innerHTML = '');
            
            toggleInteractionButtons(false);
        }

        async function updateWalletInfo() {
            if (userAddress) {
                try {
                    const network = await provider.getNetwork();
                    document.getElementById('connectedAddress').textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(38)}`;
                    document.getElementById('networkInfo').textContent = `${network.name} (Chain ID: ${network.chainId})`;
                    document.getElementById('walletInfo').style.display = 'block';
                } catch (error) {
                    console.error('Error updating wallet info:', error);
                }
            }
        }

        function toggleInteractionButtons(enabled) {
            const buttons = ['buyButton', 'sellButton', 'burnButton', 'recoverButton', 'refreshBalances'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = !enabled;
            });
        }

        // =============================================
        // Token and Balance Functions
        // =============================================
        
        async function initializeTokenContracts() {
            if (!signer) {
                throw new Error('No signer available for token contract initialization');
            }
            
            let wZYSAddress, YRSAddress;
            try {
                wZYSAddress = await contract.wZYS();
                YRSAddress = await contract.YRS();
            } catch (error) {
                console.error('Failed to fetch token addresses:', error);
                throw error;
            }
            
            // Create contract instances for the tokens
            wZYSToken = new ethers.Contract(wZYSAddress, erc20ABI, signer);
            YRSToken = new ethers.Contract(YRSAddress, erc20ABI, signer);
            
            // Get token decimals
            try {
                wZYSDecimals = await wZYSToken.decimals();
                YRSDecimals = await YRSToken.decimals();
                console.log(`wZYS decimals: ${wZYSDecimals}, YRS decimals: ${YRSDecimals}`);
            } catch (error) {
                console.error('Error fetching token decimals:', error);
                // Use default values if fetching fails
                wZYSDecimals = 12;
                YRSDecimals = 18;
            }
        }

        async function getTokenAllowance(tokenContract, spender) {
            try {
                return await tokenContract.allowance(userAddress, spender);
            } catch (error) {
                console.error('Error getting allowance:', error);
                return ethers.BigNumber.from(0);
            }
        }

        async function ensureApproval(tokenContract, spender, amount, decimals, outputId) {
            if (!signer) {
                throw new Error('No signer available for approval transaction');
            }
            
            const allowance = await getTokenAllowance(tokenContract, spender);
            const amountWei = ethers.utils.parseUnits(amount.toString(), decimals);
            
            if (allowance.lt(amountWei)) {
                try {
                    document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Approving tokens... Waiting for confirmation.</div>';
                    
                    let approveTx;
                    try {
                        approveTx = await tokenContract.increaseAllowance(spender, amountWei, { gasLimit: 100000 });
                    } catch {
                        approveTx = await tokenContract.approve(spender, amountWei, { gasLimit: 100000 });
                    }
                    
                    await approveTx.wait();
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success mt-2">Approval successful!</div>';
                } catch (error) {
                    console.error('Approval failed:', error);
                    document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Approval failed: ${error.message}</div>`;
                    throw error;
                }
            } else {
                document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Sufficient allowance found. Skipping approval.</div>';
            }
        }

        async function refreshAllBalances() {
            if (!userAddress) {
                return;
            }
            
            try {
                // If we have token contracts initialized, use them
                if (wZYSToken && YRSToken) {
                    const wZYSBalance = await wZYSToken.balanceOf(userAddress);
                    document.getElementById('wZYSBalance').textContent = parseFloat(ethers.utils.formatUnits(wZYSBalance, wZYSDecimals)).toFixed(4);
                    
                    const YRSBalance = await YRSToken.balanceOf(userAddress);
                    document.getElementById('YRSBalance').textContent = parseFloat(ethers.utils.formatUnits(YRSBalance, YRSDecimals)).toFixed(4);
                    
                    const contractBalance = await YRSToken.balanceOf(contractAddress);
                    document.getElementById('contractYRSBalance').textContent = parseFloat(ethers.utils.formatUnits(contractBalance, YRSDecimals)).toFixed(4);
                }
                
                document.getElementById('balanceError').style.display = 'none';
            } catch (error) {
                console.error('Error refreshing balances:', error);
                document.getElementById('balanceError').style.display = 'block';
            }
        }

        // =============================================
        // Contract Interaction Functions
        // =============================================
        
        async function buyYRS() {
            if (!userAddress || !signer) {
                alert('Please connect your wallet!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const wZYSAmount = parseFloat(document.getElementById('buyWZYSAmount').value);
            const minYRSOut = parseFloat(document.getElementById('minYRSOut').value);
            
            if (!wZYSAmount || !minYRSOut || wZYSAmount <= 0 || minYRSOut <= 0) {
                alert('Please enter valid positive amounts!');
                return;
            }
            
            const outputId = 'buyOutput';
            try {
                const wZYSAddress = await contract.wZYS();
                const wZYSTokenWithSigner = new ethers.Contract(wZYSAddress, erc20ABI, signer);
                await ensureApproval(wZYSTokenWithSigner, contractAddress, wZYSAmount, wZYSDecimals, outputId);
                
                const buyTx = await contract.buy1(
                    ethers.utils.parseUnits(wZYSAmount.toString(), wZYSDecimals),
                    ethers.utils.parseUnits(minYRSOut.toString(), YRSDecimals),
                    { gasLimit: 500000 }
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Buy transaction submitted! Waiting for confirmation...</div>';
                const receipt = await buyTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully bought YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error buying YRS:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. This may be due to insufficient funds, wrong parameters, or contract revert. Try adjusting slippage or amounts.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balances, allowances, or slippage protection.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function sellYRS() {
            if (!userAddress || !signer) {
                alert('Please connect your wallet!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const YRSAmount = parseFloat(document.getElementById('sellYRSAmount').value);
            const minWZYSOut = parseFloat(document.getElementById('minWZYSOut').value);
            
            if (!YRSAmount || !minWZYSOut || YRSAmount <= 0 || minWZYSOut <= 0) {
                alert('Please enter valid positive amounts!');
                return;
            }
            
            const outputId = 'sellOutput';
            try {
                const YRSAddress = await contract.YRS();
                const YRSTokenWithSigner = new ethers.Contract(YRSAddress, erc20ABI, signer);
                await ensureApproval(YRSTokenWithSigner, contractAddress, YRSAmount, YRSDecimals, outputId);
                
                const sellTx = await contract.sell1(
                    ethers.utils.parseUnits(YRSAmount.toString(), YRSDecimals),
                    ethers.utils.parseUnits(minWZYSOut.toString(), wZYSDecimals),
                    { gasLimit: 500000 }
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Sell transaction submitted! Waiting for confirmation...</div>';
                const receipt = await sellTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully sold YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error selling YRS:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. This may be due to insufficient funds, wrong parameters, or contract revert. Try adjusting slippage or amounts.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balances, allowances, or slippage protection.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function burnYRS() {
            if (!userAddress || !signer) {
                alert('Please connect your wallet!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const burnAmount = parseFloat(document.getElementById('burnAmount').value);
            
            if (!burnAmount || burnAmount <= 0) {
                alert('Please enter a valid positive amount to burn!');
                return;
            }
            
            const outputId = 'burnOutput';
            try {
                const YRSAddress = await contract.YRS();
                const YRSTokenWithSigner = new ethers.Contract(YRSAddress, erc20ABI, signer);
                await ensureApproval(YRSTokenWithSigner, contractAddress, burnAmount, YRSDecimals, outputId);
                
                const burnTx = await contract.burn(
                    ethers.utils.parseUnits(burnAmount.toString(), YRSDecimals),
                    { gasLimit: 300000 }
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Burn transaction submitted! Waiting for confirmation...</div>';
                const receipt = await burnTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully burned YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error burning YRS:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. Try a smaller amount.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balance or allowance.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function recoverTokens() {
            if (!userAddress || !signer) {
                alert('Please connect your wallet!');
                return;
            }
            
            const isCorrectNetwork = await checkNetwork();
            if (!isCorrectNetwork) {
                alert('Please switch to Sepolia testnet to proceed with this transaction!');
                return;
            }
            
            const tokenAddress = document.getElementById('recoverTokenAddress').value;
            const amount = parseFloat(document.getElementById('recoverAmount').value);
            
            if (!tokenAddress || !amount || amount <= 0) {
                alert('Please fill in all fields with valid positive amounts!');
                return;
            }
            
            if (!ethers.utils.isAddress(tokenAddress)) {
                alert('Please enter a valid token address!');
                return;
            }
            
            const outputId = 'recoverOutput';
            try {
                const recoverTx = await contract.recoverERC20(
                    tokenAddress,
                    ethers.utils.parseUnits(amount.toString(), 18), // Assuming 18 decimals for recovered tokens
                    { gasLimit: 200000 }
                );
                
                document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Recovery transaction submitted! Waiting for confirmation...</div>';
                const receipt = await recoverTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully recovered tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
            } catch (error) {
                console.error('Error recovering tokens:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. Ensure you are the contract owner.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Only contract owner can recover tokens.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }
    </script>
</body>
</html>
