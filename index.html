<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YRS Staking DApp</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Ethers.js library for blockchain interaction -->
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        .card { margin-bottom: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .status-connected { color: #198754; font-weight: bold; }
        .status-disconnected { color: #dc3545; font-weight: bold; }
        .function-section { border-left: 4px solid #0d6efd; padding-left: 1rem; margin-bottom: 2rem; }
        .wallet-info { background-color: #f8f9fa; padding: 1rem; border-radius: 0.375rem; }
        .gas-error, .rpc-error { color: #dc3545; font-size: 0.9em; }
        .retry-btn { margin-top: 0.5rem; }
        .browser-warning { display: none; background-color: #fff3cd; border-left: 4px solid #ffc107; padding: 1rem; margin-bottom: 1rem; }
        .metamask-warning { background-color: #fff3cd; border-left: 4px solid #ffc107; margin-bottom: 1rem; }
    </style>
</head>
<body>
    <div class="container mt-4 mb-5">
        <!-- Browser Compatibility Warning -->
        <div id="browserWarning" class="browser-warning">
            <strong>‚ö†Ô∏è Browser Compatibility Notice</strong>
            <p class="mb-1">Firefox may have compatibility issues with MetaMask. If you encounter connection problems:</p>
            <ul class="small mb-2">
                <li>Ensure MetaMask is installed and unlocked</li>
                <li>Try refreshing the page</li>
                <li>Check if MetaMask is connected to the correct network (Sepolia)</li>
                <li>As a last resort, try using Chrome or Brave browser</li>
            </ul>
        </div>

        <!-- MetaMask SES Warning Info -->
        <div id="metamaskWarning" class="metamask-warning alert alert-warning" style="display: none;">
            <strong>‚ö†Ô∏è MetaMask Security Notices Detected</strong>
            <p class="mb-1">The warnings in your console about 'lockdown-install.js' are from MetaMask's security system and don't affect functionality. <a href="#" id="hideMetamaskWarning" class="alert-link">Hide this message</a></p>
        </div>

        <h1 class="text-center mb-4">YRS Staking Interface</h1>
        
        <!-- Connection Status and Wallet Info -->
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Wallet Connection</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <p>Connection Status: <span id="connectionStatus" class="status-disconnected">Not Connected</span></p>
                        <div id="rpcWarning" class="alert alert-warning" style="display: none;">
                            <strong>‚ö†Ô∏è RPC Circuit Breaker Open</strong>
                            <p class="mb-1">The RPC endpoint is temporarily limiting requests. This is usually temporary and can be resolved by:</p>
                            <ul class="small mb-2">
                                <li>Waiting a few moments and retrying</li>
                                <li>Refreshing the page</li>
                                <li>Switching to a different RPC endpoint in MetaMask</li>
                                <li>Resetting your MetaMask account (Settings ‚Üí Advanced ‚Üí Reset Account)</li>
                            </ul>
                            <button id="retryInitBtn" class="btn btn-sm btn-outline-primary retry-btn">Retry Connection</button>
                        </div>
                        <div id="networkAlert" class="alert network-alert" style="display: none;">
                            <strong>üåê Network Change Required</strong>
                            <p class="mb-1">You need to switch to the Sepolia testnet to use this DApp.</p>
                            <button id="switchNetworkBtn" class="btn btn-sm btn-warning mt-1">Switch to Sepolia</button>
                        </div>
                        <button id="connectButton" class="btn btn-primary">Connect MetaMask</button>
                        <button id="disconnectButton" class="btn btn-secondary" style="display: none;">Disconnect</button>
                    </div>
                    <div class="col-md-6">
                        <div id="walletInfo" style="display: none;">
                            <p>Connected Address: <strong id="connectedAddress"></strong></p>
                            <p>Network: <strong id="networkInfo"></strong></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Token Balances -->
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Token Balances</h5>
                <button id="refreshBalances" class="btn btn-sm btn-outline-secondary" disabled>Refresh</button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <p>wZYS Balance: <strong id="wZYSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>YRS Balance: <strong id="YRSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>Contract YRS Reserve: <strong id="contractYRSBalance">0</strong></p>
                    </div>
                </div>
                <p id="balanceError" class="rpc-error" style="display: none;">Failed to load balances due to RPC error. Retry after fixing connection.</p>
            </div>
        </div>

        <!-- Contract Interaction Sections -->
        
        <!-- Buy YRS Tokens -->
        <div class="function-section">
            <h3>Buy YRS Tokens (10% Bonus)</h3>
            <p class="text-muted">Exchange your wZYS for YRS tokens and receive a 10% bonus.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="buyWZYSAmount" class="form-label">wZYS Amount to Spend</label>
                        <input type="number" class="form-control" id="buyWZYSAmount" placeholder="Enter wZYS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minYRSOut" class="form-label">Minimum YRS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minYRSOut" placeholder="Enter minimum YRS expected" step="0.000000000000000001">
                    </div>
                    <button id="buyButton" class="btn btn-success" disabled>Buy YRS</button>
                    <div id="buyOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Sell YRS Tokens -->
        <div class="function-section">
            <h3>Sell YRS Tokens (10% Penalty)</h3>
            <p class="text-muted">Exchange your YRS tokens back to wZYS with a 10% reduction.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="sellYRSAmount" class="form-label">YRS Amount to Sell</label>
                        <input type="number" class="form-control" id="sellYRSAmount" placeholder="Enter YRS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minWZYSOut" class="form-label">Minimum wZYS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minWZYSOut" placeholder="Enter minimum wZYS expected" step="0.000000000000000001">
                    </div>
                    <button id="sellButton" class="btn btn-warning" disabled>Sell YRS</button>
                    <div id="sellOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Burn YRS Tokens -->
        <div class="function-section">
            <h3>Burn YRS Tokens</h3>
            <p class="text-muted">Permanently remove YRS tokens from circulation.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="burnAmount" class="form-label">YRS Amount to Burn</label>
                        <input type="number" class="form-control" id="burnAmount" placeholder="Enter YRS amount to burn" step="0.000000000000000001">
                    </div>
                    <button id="burnButton" class="btn btn-danger" disabled>Burn YRS</button>
                    <div id="burnOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Admin Functions (Only for Contract Owner) -->
        <div class="function-section">
            <h3>Admin Functions</h3>
            <p class="text-muted">These functions are only available to the contract owner.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="recoverTokenAddress" class="form-label">Token Address to Recover</label>
                        <input type="text" class="form-control" id="recoverTokenAddress" placeholder="Enter token address">
                    </div>
                    <div class="mb-3">
                        <label for="recoverAmount" class="form-label">Amount to Recover</label>
                        <input type="number" class="form-control" id="recoverAmount" placeholder="Enter amount to recover" step="0.000000000000000001">
                    </div>
                    <button id="recoverButton" class="btn btn-info" disabled>Recover ERC20 Tokens</button>
                    <div id="recoverOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // =============================================
        // Configuration and Contract Setup
        // =============================================
        
        // Contract address and ABI
        const contractAddress = '0x0eba64eA7d1055Cb87654EC554360741C31650E6';
        const EXPECTED_CHAIN_ID = 11155111; // Sepolia testnet
        const SEPOLIA_HEX_CHAIN_ID = '0xaa36a7'; // Sepolia chain ID in hexadecimal
        
        // Contract ABI and ERC20 ABI (unchanged from your original)
        const contractABI = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "wZYSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minYRSOut", "type": "uint256"}
                ],
                "name": "buy1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            // ... (include the rest of your ABI as in your original file)
        ];

        const erc20ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            // ... (include the rest of your ERC20 ABI as in your original file)
        ];

        // Global variables
        let provider;
        let signer;
        let contract;
        let userAddress;
        let wZYSToken;
        let YRSToken;
        let initFailed = false;
        let circuitBreakerRetryCount = 0;
        const MAX_CIRCUIT_BREAKER_RETRIES = 3;

        // =============================================
        // Enhanced Provider Detection and Error Handling
        // =============================================
        
        function getEthereumProvider() {
            // Check for modern EIP-1193 provider
            if (window.ethereum) {
                return window.ethereum;
            }
            // Check for legacy web3 provider
            else if (window.web3 && window.web3.currentProvider) {
                return window.web3.currentProvider;
            }
            // No provider found
            return null;
        }

        function handleRPCCircuitBreaker(error, context = '') {
            const circuitBreakerIndicators = [
                'circuit breaker',
                'execution prevented',
                'rpc error',
                'transport is closing',
                'unavailable',
                'unknown account'
            ];
            
            const isCircuitBreakerError = circuitBreakerIndicators.some(indicator => 
                error.message?.toLowerCase().includes(indicator) || 
                error.toString().toLowerCase().includes(indicator)
            );
            
            if (isCircuitBreakerError || error.code === -32603 || error.code === 'SERVER_ERROR' || error.code === 'UNSUPPORTED_OPERATION') {
                console.error(`RPC/Circuit Breaker Error in ${context}:`, error);
                document.getElementById('rpcWarning').style.display = 'block';
                initFailed = true;
                circuitBreakerRetryCount++;
                
                toggleInteractionButtons(false);
                return true;
            }
            return false;
        }

        // Enhanced retryableCall with better error handling
        async function retryableCall(callFn, maxRetries = 3, delay = 1000) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const result = await callFn();
                    // Reset circuit breaker retry count on successful call
                    if (i > 0) {
                        circuitBreakerRetryCount = 0;
                        initFailed = false;
                        document.getElementById('rpcWarning').style.display = 'none';
                    }
                    return result;
                } catch (error) {
                    // Handle "unknown account" error specifically - this is critical for Firefox
                    if (error.code === 'UNSUPPORTED_OPERATION' && error.message.includes('unknown account')) {
                        console.warn('Unknown account error detected, likely no wallet connected');
                        throw new Error('No wallet connected. Please connect MetaMask first.');
                    }
                    
                    if (handleRPCCircuitBreaker(error, `Retry ${i + 1} for call`)) {
                        if (circuitBreakerRetryCount >= MAX_CIRCUIT_BREAKER_RETRIES) {
                            console.warn('Max circuit breaker retries reached, giving up');
                            break;
                        }
                    }
                    if (i < maxRetries - 1 && !initFailed) {
                        console.log(`Retry ${i + 1} failed, waiting ${delay * (i + 1)}ms before retry`);
                        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));
                    } else {
                        throw error;
                    }
                }
            }
            throw new Error('All retry attempts failed');
        }

        function toggleInteractionButtons(enabled) {
            const buttons = ['buyButton', 'sellButton', 'burnButton', 'recoverButton', 'refreshBalances'];
            buttons.forEach(id => {
                document.getElementById(id).disabled = !enabled;
            });
        }

        // =============================================
        // MetaMask SES Warning Handler
        // =============================================
        
        function checkForMetaMaskWarnings() {
            // Check if we're in Firefox and show appropriate warnings
            if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
                document.getElementById('browserWarning').style.display = 'block';
            }
            
            // Show MetaMask SES warning info (these warnings are harmless)
            document.getElementById('metamaskWarning').style.display = 'block';
        }

        // =============================================
        // DOM Content Loaded Event Listener
        // =============================================
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Check for MetaMask warnings
            checkForMetaMaskWarnings();
            
            // Enhanced provider detection
            const ethereumProvider = getEthereumProvider();
            
            if (!ethereumProvider) {
                alert('Please install MetaMask to use this dApp!');
                return;
            }

            try {
                // Initialize the provider with the detected Ethereum provider
                provider = new ethers.providers.Web3Provider(ethereumProvider, "any");
                
                // Initialize contract object (read-only until signer is connected)
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            } catch (error) {
                console.error('Error initializing contract:', error);
                alert('Error initializing contract. Please check the console for details.');
                return;
            }

            // Set up event listeners
            document.getElementById('connectButton').addEventListener('click', connectWallet);
            document.getElementById('disconnectButton').addEventListener('click', disconnectWallet);
            document.getElementById('buyButton').addEventListener('click', buyYRS);
            document.getElementById('sellButton').addEventListener('click', sellYRS);
            document.getElementById('burnButton').addEventListener('click', burnYRS);
            document.getElementById('recoverButton').addEventListener('click', recoverTokens);
            document.getElementById('refreshBalances').addEventListener('click', refreshAllBalances);
            document.getElementById('retryInitBtn').addEventListener('click', retryInitialization);
            document.getElementById('switchNetworkBtn').addEventListener('click', switchToSepoliaNetwork);
            document.getElementById('hideMetamaskWarning').addEventListener('click', function(e) {
                e.preventDefault();
                document.getElementById('metamaskWarning').style.display = 'none';
            });

            // Enhanced event listeners for account and chain changes
            if (ethereumProvider.on) {
                ethereumProvider.on('accountsChanged', async function(accounts) {
                    if (accounts.length === 0) {
                        disconnectWallet();
                    } else {
                        await connectWallet(accounts[0]);
                    }
                });

                ethereumProvider.on('chainChanged', async function(chainId) {
                    circuitBreakerRetryCount = 0;
                    initFailed = false;
                    document.getElementById('rpcWarning').style.display = 'none';
                    
                    await checkNetwork();
                    if (userAddress) {
                        await refreshAllBalances();
                    }
                });
            }

            // Initial check for existing connection with better error handling
            try {
                const accounts = await provider.listAccounts();
                if (accounts.length > 0) {
                    await connectWallet(accounts[0]);
                }
            } catch (error) {
                console.log('No accounts found or error listing accounts:', error);
            }
        });

        // =============================================
        // Enhanced Wallet Connection Functions
        // =============================================
        
        async function connectWallet(overrideAddress = null) {
            try {
                const ethereumProvider = getEthereumProvider();
                if (!ethereumProvider) {
                    throw new Error('No Ethereum provider found. Please install MetaMask.');
                }

                let accounts;
                if (overrideAddress) {
                    accounts = [overrideAddress];
                } else {
                    accounts = await ethereumProvider.request({ method: 'eth_requestAccounts' });
                }
                
                if (accounts.length === 0) {
                    throw new Error('No accounts available');
                }

                // Re-initialize provider with current context
                provider = new ethers.providers.Web3Provider(ethereumProvider, "any");
                
                // CRITICAL FIX: Get signer with explicit account to prevent "unknown account" error
                try {
                    userAddress = accounts[0];
                    // Explicitly get signer with the connected account
                    signer = provider.getSigner(userAddress);
                } catch (signerError) {
                    console.error('Error getting signer:', signerError);
                    // Fallback for Firefox compatibility issues
                    if (signerError.code === 'UNSUPPORTED_OPERATION') {
                        userAddress = accounts[0];
                        signer = provider.getSigner();
                        console.warn('Using fallback signer approach for Firefox compatibility');
                    } else {
                        throw signerError;
                    }
                }
                
                // Update contract instance with signer for write operations
                contract = contract.connect(signer);
                
                // Check network
                const isCorrectNetwork = await checkNetwork();
                if (!isCorrectNetwork) {
                    document.getElementById('networkAlert').style.display = 'block';
                } else {
                    document.getElementById('networkAlert').style.display = 'none';
                }
                
                // Update UI
                updateWalletInfo();
                
                // Initialize token contracts with retry
                try {
                    await retryableCall(initializeTokenContracts);
                    initFailed = false;
                    document.getElementById('rpcWarning').style.display = 'none';
                } catch (error) {
                    console.error('Failed to initialize after retries:', error);
                    initFailed = true;
                    document.getElementById('rpcWarning').style.display = 'block';
                    // Show user-friendly error message
                    if (error.message.includes('No wallet connected')) {
                        document.getElementById('rpcWarning').innerHTML = `
                            <strong>‚ö†Ô∏è Wallet Connection Required</strong>
                            <p class="mb-1">Please connect your MetaMask wallet to continue.</p>
                            <button id="retryInitBtn" class="btn btn-sm btn-outline-primary retry-btn">Retry Connection</button>
                        `;
                    }
                }
                
                // Refresh balances
                if (!initFailed) {
                    await refreshAllBalances();
                } else {
                    document.getElementById('balanceError').style.display = 'block';
                }
                
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'status-connected';
                document.getElementById('connectButton').style.display = 'none';
                document.getElementById('disconnectButton').style.display = 'inline-block';
                
                toggleInteractionButtons(!initFailed && isCorrectNetwork);
                
            } catch (error) {
                console.error('Error connecting to wallet:', error);
                if (error.code !== 4001 && !handleRPCCircuitBreaker(error, 'connectWallet')) {
                    alert('Error connecting to MetaMask: ' + error.message);
                }
            }
        }

        async function retryInitialization() {
            if (!userAddress) return;
            try {
                document.getElementById('rpcWarning').style.display = 'none';
                
                await retryableCall(initializeTokenContracts, 2, 2000);
                initFailed = false;
                await refreshAllBalances();
                document.getElementById('balanceError').style.display = 'none';
                
                const isCorrectNetwork = await checkNetwork();
                toggleInteractionButtons(isCorrectNetwork);
            } catch (error) {
                console.error('Retry failed:', error);
                handleRPCCircuitBreaker(error, 'retryInitialization');
            }
        }

        // =============================================
        // Enhanced Token Contract Initialization
        // =============================================
        
        async function initializeTokenContracts() {
            if (!signer) {
                throw new Error('No signer available for token contract initialization');
            }
            
            // CRITICAL FIX: Verify we have a valid signer before proceeding
            try {
                // This will throw "unknown account" error if no account is connected
                await signer.getAddress();
            } catch (error) {
                if (error.code === 'UNSUPPORTED_OPERATION') {
                    throw new Error('No wallet connected. Please connect MetaMask first.');
                }
                throw error;
            }
            
            let wZYSAddress, YRSAddress;
            try {
                wZYSAddress = await retryableCall(() => contract.wZYS());
                YRSAddress = await retryableCall(() => contract.YRS());
            } catch (error) {
                console.error('Failed to fetch token addresses:', error);
                throw error;
            }
            
            // Create contract instances for the tokens
            wZYSToken = new ethers.Contract(wZYSAddress, erc20ABI, signer);
            YRSToken = new ethers.Contract(YRSAddress, erc20ABI, signer);
        }

        // =============================================
        // Network Switching Functions (unchanged)
        // =============================================
        
        async function switchToSepoliaNetwork() {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: SEPOLIA_HEX_CHAIN_ID }],
                });
                return true;
            } catch (switchError) {
                if (switchError.code === 4902) {
                    try {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [
                                {
                                    chainId: SEPOLIA_HEX_CHAIN_ID,
                                    chainName: 'Sepolia Test Network',
                                    rpcUrls: ['https://rpc.sepolia.org/'],
                                    blockExplorerUrls: ['https://sepolia.etherscan.io/'],
                                    nativeCurrency: {
                                        name: 'Sepolia Ether',
                                        symbol: 'ETH',
                                        decimals: 18
                                    },
                                },
                            ],
                        });
                        return true;
                    } catch (addError) {
                        console.error('Error adding Sepolia network:', addError);
                        alert('Failed to add Sepolia network to MetaMask. Please add it manually.');
                        return false;
                    }
                } else if (switchError.code === 4001) {
                    console.log('User rejected network switch');
                    return false;
                } else {
                    console.error('Error switching to Sepolia:', switchError);
                    return false;
                }
            }
        }

        async function checkNetwork() {
            try {
                const network = await provider.getNetwork();
                const isCorrectNetwork = network.chainId === EXPECTED_CHAIN_ID;
                
                if (!isCorrectNetwork) {
                    console.log(`Expected Chain ID ${EXPECTED_CHAIN_ID}, but connected to ${network.chainId}. Showing network switch prompt.`);
                    document.getElementById('networkAlert').style.display = 'block';
                    toggleInteractionButtons(false);
                    return false;
                } else {
                    document.getElementById('networkAlert').style.display = 'none';
                    if (!initFailed) {
                        toggleInteractionButtons(true);
                    }
                    return true;
                }
            } catch (error) {
                console.error('Error checking network:', error);
                if (handleRPCCircuitBreaker(error, 'checkNetwork')) {
                    return false;
                }
                document.getElementById('networkAlert').style.display = 'block';
                return false;
            }
        }

        function disconnectWallet() {
            userAddress = null;
            signer = null;
            const ethereumProvider = getEthereumProvider();
            if (ethereumProvider) {
                provider = new ethers.providers.Web3Provider(ethereumProvider);
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            }
            wZYSToken = null;
            YRSToken = null;
            initFailed = false;
            circuitBreakerRetryCount = 0;
            
            document.getElementById('connectionStatus').textContent = 'Not Connected';
            document.getElementById('connectionStatus').className = 'status-disconnected';
            document.getElementById('walletInfo').style.display = 'none';
            document.getElementById('connectedAddress').textContent = '';
            document.getElementById('networkInfo').textContent = '';
            document.getElementById('connectButton').style.display = 'inline-block';
            document.getElementById('disconnectButton').style.display = 'none';
            document.getElementById('rpcWarning').style.display = 'none';
            document.getElementById('networkAlert').style.display = 'none';
            document.getElementById('balanceError').style.display = 'none';
            
            // Reset balances
            document.getElementById('wZYSBalance').textContent = '0';
            document.getElementById('YRSBalance').textContent = '0';
            document.getElementById('contractYRSBalance').textContent = '0';
            
            // Clear outputs
            document.querySelectorAll('[id$="Output"]').forEach(el => el.innerHTML = '');
            
            toggleInteractionButtons(false);
        }

        async function updateWalletInfo() {
            if (userAddress) {
                try {
                    const network = await provider.getNetwork();
                    // FIX: Added null check and string conversion for userAddress
                    const address = userAddress ? userAddress.toString() : '';
                    if (address && address.substring) {
                        document.getElementById('connectedAddress').textContent = `${address.substring(0, 6)}...${address.substring(38)}`;
                    } else {
                        document.getElementById('connectedAddress').textContent = address || 'Unknown';
                    }
                    document.getElementById('networkInfo').textContent = `${network.name} (Chain ID: ${network.chainId})`;
                    document.getElementById('walletInfo').style.display = 'block';
                } catch (error) {
                    console.error('Error updating wallet info:', error);
                    if (handleRPCCircuitBreaker(error, 'updateWalletInfo')) {
                        return;
                    }
                }
            }
        }

        // =============================================
        // Balance and Contract Interaction Functions 
        // (keep your existing implementations for these)
        // =============================================
        
        async function refreshAllBalances() {
            if (!userAddress || initFailed) {
                if (initFailed) {
                    document.getElementById('balanceError').style.display = 'block';
                }
                return;
            }
            
            try {
                if (wZYSToken && YRSToken) {
                    const wZYSBalance = await retryableCall(() => wZYSToken.balanceOf(userAddress));
                    document.getElementById('wZYSBalance').textContent = parseFloat(ethers.utils.formatUnits(wZYSBalance, 18)).toFixed(4);
                    
                    const YRSBalance = await retryableCall(() => YRSToken.balanceOf(userAddress));
                    document.getElementById('YRSBalance').textContent = parseFloat(ethers.utils.formatUnits(YRSBalance, 18)).toFixed(4);
                    
                    const contractBalance = await retryableCall(() => YRSToken.balanceOf(contractAddress));
                    document.getElementById('contractYRSBalance').textContent = parseFloat(ethers.utils.formatUnits(contractBalance, 18)).toFixed(4);
                }
                
                document.getElementById('balanceError').style.display = 'none';
            } catch (error) {
                console.error('Error refreshing balances:', error);
                if (handleRPCCircuitBreaker(error, 'refreshAllBalances')) {
                    document.getElementById('balanceError').style.display = 'block';
                }
            }
        }

        // Include your existing buyYRS, sellYRS, burnYRS, recoverTokens functions
        // They should work with the fixes above

        async function buyYRS() {
            // Your existing buyYRS implementation
        }

        async function sellYRS() {
            // Your existing sellYRS implementation  
        }

        async function burnYRS() {
            // Your existing burnYRS implementation
        }

        async function recoverTokens() {
            // Your existing recoverTokens implementation
        }

        // Include other helper functions like getTokenAllowance, ensureApproval etc.
        // from your original code
    </script>
</body>
</html>
