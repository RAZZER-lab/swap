<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YRS Staking DApp</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Ethers.js library for blockchain interaction (updated CDN) -->
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        .card { margin-bottom: 1.5rem; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .status-connected { color: #198754; font-weight: bold; }
        .status-disconnected { color: #dc3545; font-weight: bold; }
        .function-section { border-left: 4px solid #0d6efd; padding-left: 1rem; margin-bottom: 2rem; }
        .wallet-info { background-color: #f8f9fa; padding: 1rem; border-radius: 0.375rem; }
        .gas-error { color: #dc3545; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container mt-4 mb-5">
        <h1 class="text-center mb-4">YRS Staking Interface</h1>
        
        <!-- Connection Status and Wallet Info -->
        <div class="card">
            <div class="card-header">
                <h5 class="mb-0">Wallet Connection</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-6">
                        <p>Connection Status: <span id="connectionStatus" class="status-disconnected">Not Connected</span></p>
                        <p id="networkWarning" class="gas-error" style="display: none;">⚠️ Wrong Network! Switch to the correct chain.</p>
                        <button id="connectButton" class="btn btn-primary">Connect MetaMask</button>
                        <button id="disconnectButton" class="btn btn-secondary" style="display: none;">Disconnect</button>
                    </div>
                    <div class="col-md-6">
                        <div id="walletInfo" style="display: none;">
                            <p>Connected Address: <strong id="connectedAddress"></strong></p>
                            <p>Network: <strong id="networkInfo"></strong></p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Token Balances -->
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Token Balances</h5>
                <button id="refreshBalances" class="btn btn-sm btn-outline-secondary">Refresh</button>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <p>wZYS Balance: <strong id="wZYSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>YRS Balance: <strong id="YRSBalance">0</strong></p>
                    </div>
                    <div class="col-md-4">
                        <p>Contract YRS Reserve: <strong id="contractYRSBalance">0</strong></p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Contract Interaction Sections -->
        
        <!-- Buy YRS Tokens -->
        <div class="function-section">
            <h3>Buy YRS Tokens (10% Bonus)</h3>
            <p class="text-muted">Exchange your wZYS for YRS tokens and receive a 10% bonus.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="buyWZYSAmount" class="form-label">wZYS Amount to Spend</label>
                        <input type="number" class="form-control" id="buyWZYSAmount" placeholder="Enter wZYS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minYRSOut" class="form-label">Minimum YRS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minYRSOut" placeholder="Enter minimum YRS expected" step="0.000000000000000001">
                    </div>
                    <button id="buyButton" class="btn btn-success">Buy YRS</button>
                    <div id="buyOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Sell YRS Tokens -->
        <div class="function-section">
            <h3>Sell YRS Tokens (10% Penalty)</h3>
            <p class="text-muted">Exchange your YRS tokens back to wZYS with a 10% reduction.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="sellYRSAmount" class="form-label">YRS Amount to Sell</label>
                        <input type="number" class="form-control" id="sellYRSAmount" placeholder="Enter YRS amount" step="0.000000000000000001">
                    </div>
                    <div class="mb-3">
                        <label for="minWZYSOut" class="form-label">Minimum wZYS to Receive (Slippage Protection)</label>
                        <input type="number" class="form-control" id="minWZYSOut" placeholder="Enter minimum wZYS expected" step="0.000000000000000001">
                    </div>
                    <button id="sellButton" class="btn btn-warning">Sell YRS</button>
                    <div id="sellOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Burn YRS Tokens -->
        <div class="function-section">
            <h3>Burn YRS Tokens</h3>
            <p class="text-muted">Permanently remove YRS tokens from circulation.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="burnAmount" class="form-label">YRS Amount to Burn</label>
                        <input type="number" class="form-control" id="burnAmount" placeholder="Enter YRS amount to burn" step="0.000000000000000001">
                    </div>
                    <button id="burnButton" class="btn btn-danger">Burn YRS</button>
                    <div id="burnOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

        <!-- Admin Functions (Only for Contract Owner) -->
        <div class="function-section">
            <h3>Admin Functions</h3>
            <p class="text-muted">These functions are only available to the contract owner.</p>
            <div class="row">
                <div class="col-md-8">
                    <div class="mb-3">
                        <label for="recoverTokenAddress" class="form-label">Token Address to Recover</label>
                        <input type="text" class="form-control" id="recoverTokenAddress" placeholder="Enter token address">
                    </div>
                    <div class="mb-3">
                        <label for="recoverAmount" class="form-label">Amount to Recover</label>
                        <input type="number" class="form-control" id="recoverAmount" placeholder="Enter amount to recover" step="0.000000000000000001">
                    </div>
                    <button id="recoverButton" class="btn btn-info">Recover ERC20 Tokens</button>
                    <div id="recoverOutput" class="mt-2"></div>
                </div>
            </div>
        </div>

    </div>

    <script>
        // =============================================
        // Configuration and Contract Setup
        // =============================================
        
        // Contract address and ABI
        const contractAddress = '0x0eba64eA7d1055Cb87654EC554360741C31650E6';
        const EXPECTED_CHAIN_ID = 1; // Change this to the correct chain ID for your contract (e.g., 1 for Ethereum Mainnet, 137 for Polygon, etc.)
        
        // Proper ABI for the YRSStaking contract (inferred from function signatures)
        const contractABI = [
            {
                "inputs": [
                    {"internalType": "uint256", "name": "wZYSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minYRSOut", "type": "uint256"}
                ],
                "name": "buy1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "YRSAmount", "type": "uint256"},
                    {"internalType": "uint256", "name": "minWZYSOut", "type": "uint256"}
                ],
                "name": "sell1",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "burn",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {"internalType": "address", "name": "tokenAddress", "type": "address"},
                    {"internalType": "uint256", "name": "amount", "type": "uint256"}
                ],
                "name": "recoverERC20",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalYieldReserveShares",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "totalWZYSDeposited",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "wZYS",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "YRS",
                "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "BONUS_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "PENALTY_PERCENT",
                "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                "stateMutability": "view",
                "type": "function"
            }
        ];

        // Standard ERC20 ABI for token interactions
        const erc20ABI = [
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_value", "type": "uint256"}
                ],
                "name": "approve",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            },
            {
                "constant": false,
                "inputs": [
                    {"name": "_spender", "type": "address"},
                    {"name": "_subtractor", "type": "uint256"},
                    {"name": "_addedValue", "type": "uint256"}
                ],
                "name": "increaseAllowance",
                "outputs": [{"name": "", "type": "bool"}],
                "type": "function"
            }
        ];

        // Global variables
        let provider;
        let signer;
        let contract;
        let userAddress;
        let wZYSToken;
        let YRSToken;

        // =============================================
        // DOM Content Loaded Event Listener
        // =============================================
        
        document.addEventListener('DOMContentLoaded', async function() {
            // Check if MetaMask is installed
            if (typeof window.ethereum === 'undefined') {
                alert('Please install MetaMask to use this dApp!');
                return;
            }

            // Initialize the provider
            provider = new ethers.providers.Web3Provider(window.ethereum);
            
            // Initialize contract object (read-only until signer is connected)
            try {
                contract = new ethers.Contract(contractAddress, contractABI, provider);
            } catch (error) {
                console.error('Error initializing contract:', error);
                alert('Error initializing contract. Please check the console for details.');
                return;
            }

            // Check if already connected on load
            try {
                const accounts = await provider.listAccounts();
                if (accounts.length > 0) {
                    await connectWallet(accounts[0]);
                }
            } catch (error) {
                console.log('No accounts found, waiting for manual connection.');
            }

            // Set up event listeners
            document.getElementById('connectButton').addEventListener('click', connectWallet);
            document.getElementById('disconnectButton').addEventListener('click', disconnectWallet);
            document.getElementById('buyButton').addEventListener('click', buyYRS);
            document.getElementById('sellButton').addEventListener('click', sellYRS);
            document.getElementById('burnButton').addEventListener('click', burnYRS);
            document.getElementById('recoverButton').addEventListener('click', recoverTokens);
            document.getElementById('refreshBalances').addEventListener('click', refreshAllBalances);

            // Listen for account changes
            window.ethereum.on('accountsChanged', async function(accounts) {
                if (accounts.length === 0) {
                    disconnectWallet();
                } else {
                    await connectWallet(accounts[0]);
                }
            });

            // Listen for chain changes
            window.ethereum.on('chainChanged', async function(chainId) {
                await checkNetwork();
                if (userAddress) {
                    await refreshAllBalances();
                }
            });
        });

        // =============================================
        // Wallet Connection Functions
        // =============================================
        
        async function connectWallet(overrideAddress = null) {
            try {
                let accounts;
                if (overrideAddress) {
                    accounts = [overrideAddress];
                } else {
                    accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                }
                
                if (accounts.length === 0) {
                    throw new Error('No accounts available');
                }

                // Get the signer
                signer = provider.getSigner();
                userAddress = accounts[0];
                
                // Update contract instance with signer for write operations
                contract = contract.connect(signer);
                
                // Initialize token contracts
                await initializeTokenContracts();
                
                // Check network
                await checkNetwork();
                
                // Update UI
                updateWalletInfo();
                await refreshAllBalances();
                
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'status-connected';
                document.getElementById('connectButton').style.display = 'none';
                document.getElementById('disconnectButton').style.display = 'inline-block';
                
            } catch (error) {
                console.error('Error connecting to wallet:', error);
                if (error.code !== 4001) { // Ignore user rejection
                    alert('Error connecting to MetaMask: ' + error.message);
                }
            }
        }

        async function checkNetwork() {
            try {
                const network = await provider.getNetwork();
                if (network.chainId !== EXPECTED_CHAIN_ID) {
                    document.getElementById('networkWarning').style.display = 'block';
                    document.getElementById('networkWarning').textContent = `⚠️ Wrong Network! Expected Chain ID ${EXPECTED_CHAIN_ID}, but connected to ${network.chainId}. Switch to the correct network.`;
                    return false;
                } else {
                    document.getElementById('networkWarning').style.display = 'none';
                    return true;
                }
            } catch (error) {
                console.error('Error checking network:', error);
                return false;
            }
        }

        function disconnectWallet() {
            userAddress = null;
            signer = null;
            contract = new ethers.Contract(contractAddress, contractABI, provider);
            wZYSToken = null;
            YRSToken = null;
            
            document.getElementById('connectionStatus').textContent = 'Not Connected';
            document.getElementById('connectionStatus').className = 'status-disconnected';
            document.getElementById('walletInfo').style.display = 'none';
            document.getElementById('connectedAddress').textContent = '';
            document.getElementById('networkInfo').textContent = '';
            document.getElementById('connectButton').style.display = 'inline-block';
            document.getElementById('disconnectButton').style.display = 'none';
            document.getElementById('networkWarning').style.display = 'none';
            
            // Reset balances
            document.getElementById('wZYSBalance').textContent = '0';
            document.getElementById('YRSBalance').textContent = '0';
            document.getElementById('contractYRSBalance').textContent = '0';
            
            // Clear outputs
            document.querySelectorAll('[id$="Output"]').forEach(el => el.innerHTML = '');
        }

        async function updateWalletInfo() {
            if (userAddress) {
                try {
                    const network = await provider.getNetwork();
                    document.getElementById('connectedAddress').textContent = `${userAddress.substring(0, 6)}...${userAddress.substring(38)}`;
                    document.getElementById('networkInfo').textContent = `${network.name} (Chain ID: ${network.chainId})`;
                    document.getElementById('walletInfo').style.display = 'block';
                } catch (error) {
                    console.error('Error updating wallet info:', error);
                }
            }
        }

        // =============================================
        // Token and Balance Functions
        // =============================================
        
        async function initializeTokenContracts() {
            try {
                // Get token addresses from the main contract
                const wZYSAddress = await contract.wZYS();
                const YRSAddress = await contract.YRS();
                
                // Create contract instances for the tokens
                wZYSToken = new ethers.Contract(wZYSAddress, erc20ABI, signer || provider);
                YRSToken = new ethers.Contract(YRSAddress, erc20ABI, signer || provider);
                
            } catch (error) {
                console.error('Error initializing token contracts:', error);
                throw error; // Re-throw to handle in caller
            }
        }

        async function getTokenAllowance(tokenContract, spender) {
            try {
                // Use allowance function if available, otherwise assume 0
                const allowance = await tokenContract.allowance(userAddress, spender);
                return allowance;
            } catch (error) {
                console.error('Error getting allowance:', error);
                return 0;
            }
        }

        async function ensureApproval(tokenContract, spender, amount, outputId) {
            const allowance = await getTokenAllowance(tokenContract, spender);
            const amountWei = ethers.utils.parseUnits(amount.toString(), 18);
            
            if (allowance.lt(amountWei)) {
                try {
                    document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Approving tokens... Waiting for confirmation.</div>';
                    
                    // Use increaseAllowance if available, else approve
                    let approveTx;
                    try {
                        approveTx = await tokenContract.increaseAllowance(spender, amountWei, { gasLimit: 100000 });
                    } catch {
                        approveTx = await tokenContract.approve(spender, amountWei, { gasLimit: 100000 });
                    }
                    
                    await approveTx.wait();
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success mt-2">Approval successful!</div>';
                } catch (error) {
                    console.error('Approval failed:', error);
                    document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Approval failed: ${error.message}</div>`;
                    throw error;
                }
            } else {
                document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Sufficient allowance found. Skipping approval.</div>';
            }
        }

        async function refreshAllBalances() {
            if (!userAddress || !wZYSToken || !YRSToken) return;
            
            try {
                // Get user's wZYS balance
                const wZYSBalance = await wZYSToken.balanceOf(userAddress);
                document.getElementById('wZYSBalance').textContent = parseFloat(ethers.utils.formatUnits(wZYSBalance, 18)).toFixed(4);
                
                // Get user's YRS balance
                const YRSBalance = await YRSToken.balanceOf(userAddress);
                document.getElementById('YRSBalance').textContent = parseFloat(ethers.utils.formatUnits(YRSBalance, 18)).toFixed(4);
                
                // Get contract's YRS balance
                const contractBalance = await YRSToken.balanceOf(contractAddress);
                document.getElementById('contractYRSBalance').textContent = parseFloat(ethers.utils.formatUnits(contractBalance, 18)).toFixed(4);
                
            } catch (error) {
                console.error('Error refreshing balances:', error);
            }
        }

        // =============================================
        // Contract Interaction Functions
        // =============================================
        
        async function buyYRS() {
            if (!userAddress || !await checkNetwork()) {
                alert('Please connect your wallet and switch to the correct network!');
                return;
            }
            
            const wZYSAmount = parseFloat(document.getElementById('buyWZYSAmount').value);
            const minYRSOut = parseFloat(document.getElementById('minYRSOut').value);
            
            if (!wZYSAmount || !minYRSOut || wZYSAmount <= 0 || minYRSOut <= 0) {
                alert('Please enter valid positive amounts!');
                return;
            }
            
            const outputId = 'buyOutput';
            try {
                // Ensure approval
                const wZYSAddress = await contract.wZYS();
                const wZYSTokenWithSigner = new ethers.Contract(wZYSAddress, erc20ABI, signer);
                await ensureApproval(wZYSTokenWithSigner, contractAddress, wZYSAmount, outputId);
                
                // Now execute the buy transaction with manual gas limit
                const buyTx = await contract.buy1(
                    ethers.utils.parseUnits(wZYSAmount.toString(), 18),
                    ethers.utils.parseUnits(minYRSOut.toString(), 18),
                    { gasLimit: 500000 } // Manual gas limit to avoid estimation issues
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Buy transaction submitted! Waiting for confirmation...</div>';
                const receipt = await buyTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully bought YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                // Refresh balances
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error buying YRS:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. This may be due to insufficient funds, wrong parameters, or contract revert. Try adjusting slippage or amounts.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balances, allowances, or slippage protection.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function sellYRS() {
            if (!userAddress || !await checkNetwork()) {
                alert('Please connect your wallet and switch to the correct network!');
                return;
            }
            
            const YRSAmount = parseFloat(document.getElementById('sellYRSAmount').value);
            const minWZYSOut = parseFloat(document.getElementById('minWZYSOut').value);
            
            if (!YRSAmount || !minWZYSOut || YRSAmount <= 0 || minWZYSOut <= 0) {
                alert('Please enter valid positive amounts!');
                return;
            }
            
            const outputId = 'sellOutput';
            try {
                // Ensure approval
                const YRSAddress = await contract.YRS();
                const YRSTokenWithSigner = new ethers.Contract(YRSAddress, erc20ABI, signer);
                await ensureApproval(YRSTokenWithSigner, contractAddress, YRSAmount, outputId);
                
                // Now execute the sell transaction with manual gas limit
                const sellTx = await contract.sell1(
                    ethers.utils.parseUnits(YRSAmount.toString(), 18),
                    ethers.utils.parseUnits(minWZYSOut.toString(), 18),
                    { gasLimit: 500000 } // Manual gas limit to avoid estimation issues
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Sell transaction submitted! Waiting for confirmation...</div>';
                const receipt = await sellTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully sold YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                // Refresh balances
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error selling YRS:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. This may be due to insufficient funds, wrong parameters, or contract revert. Try adjusting slippage or amounts.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balances, allowances, or slippage protection.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function burnYRS() {
            if (!userAddress || !await checkNetwork()) {
                alert('Please connect your wallet and switch to the correct network!');
                return;
            }
            
            const burnAmount = parseFloat(document.getElementById('burnAmount').value);
            
            if (!burnAmount || burnAmount <= 0) {
                alert('Please enter a valid positive amount to burn!');
                return;
            }
            
            const outputId = 'burnOutput';
            try {
                // Ensure approval
                const YRSAddress = await contract.YRS();
                const YRSTokenWithSigner = new ethers.Contract(YRSAddress, erc20ABI, signer);
                await ensureApproval(YRSTokenWithSigner, contractAddress, burnAmount, outputId);
                
                // Now execute the burn transaction with manual gas limit
                const burnTx = await contract.burn(
                    ethers.utils.parseUnits(burnAmount.toString(), 18),
                    { gasLimit: 300000 } // Manual gas limit
                );
                
                document.getElementById(outputId).innerHTML += '<div class="alert alert-info">Burn transaction submitted! Waiting for confirmation...</div>';
                const receipt = await burnTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully burned YRS tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
                // Refresh balances
                await refreshAllBalances();
                
            } catch (error) {
                console.error('Error burning YRS:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. Try a smaller amount.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Check balance or allowance.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }

        async function recoverTokens() {
            if (!userAddress || !await checkNetwork()) {
                alert('Please connect your wallet and switch to the correct network!');
                return;
            }
            
            const tokenAddress = document.getElementById('recoverTokenAddress').value;
            const amount = parseFloat(document.getElementById('recoverAmount').value);
            
            if (!tokenAddress || !amount || amount <= 0) {
                alert('Please fill in all fields with valid positive amounts!');
                return;
            }
            
            // Basic address validation
            if (!ethers.utils.isAddress(tokenAddress)) {
                alert('Please enter a valid token address!');
                return;
            }
            
            const outputId = 'recoverOutput';
            try {
                // Execute the recover transaction with manual gas limit
                const recoverTx = await contract.recoverERC20(
                    tokenAddress,
                    ethers.utils.parseUnits(amount.toString(), 18),
                    { gasLimit: 200000 } // Manual gas limit
                );
                
                document.getElementById(outputId).innerHTML = '<div class="alert alert-info">Recovery transaction submitted! Waiting for confirmation...</div>';
                const receipt = await recoverTx.wait();
                
                if (receipt.status === 1) {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-success">Successfully recovered tokens! Tx: ' + receipt.transactionHash + '</div>';
                } else {
                    document.getElementById(outputId).innerHTML += '<div class="alert alert-danger">Transaction failed! Check details.</div>';
                }
                
            } catch (error) {
                console.error('Error recovering tokens:', error);
                let errorMsg = error.message;
                if (error.code === 'UNPREDICTABLE_GAS_LIMIT') {
                    errorMsg = 'Gas estimation failed. Ensure you are the contract owner.';
                } else if (error.data && error.data.includes('execution reverted')) {
                    errorMsg = 'Transaction would revert. Only contract owner can recover tokens.';
                }
                document.getElementById(outputId).innerHTML = `<div class="alert alert-danger">Error: ${errorMsg}</div>`;
            }
        }
    </script>
</body>
</html>
